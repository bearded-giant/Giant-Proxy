#!/usr/bin/env bash

# === Constants ===
SCRIPT_NAME="giant-proxy"
VERSION="1.0.0"
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ "$SOURCE" != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"

RULES_FILE="$SCRIPT_DIR/rules.json"

command="$1"
shift || true

# === Helpers ===
get_profile() {
    local p=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
        --profile)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing profile name after --profile"
                exit 1
            fi
            p="$2"
            shift 2
            ;;
        *) shift ;;
        esac
    done
    if [[ -z "$p" ]]; then
        echo "‚ùå Missing --profile <name>"
        exit 1
    fi
    echo "$p"
}
is_verbose() {
    for arg in "$@"; do
        [[ "$arg" == "--verbose" ]] && return 0
    done
    return 1
}

print_help() {
    echo ""
    echo "üìñ Usage: $SCRIPT_NAME <command> [options]"
    echo ""
    echo "Commands:"
    echo "  list                      List all rules for a profile"
    echo "  toggle <rule_id>          Toggle a rule on/off"
    echo "  describe <rule_id> --profile <profile>  Show full rule JSON"
    echo "  start                     Start mitmproxy with the selected profile"
    echo "  stop                      Stop mitmproxy"
    echo "  status                    Show current proxy status"
    echo "  install                   Symlink this CLI to ~/.local/bin"
    echo "  update                    Pull latest version and sync"
    echo "  create-profile <name>     Create a new profile in rules.json"
    echo "  add-rule <id> --profile <profile> --regex <r> --host <h> --port <p> [--scheme <http|https>]"
    echo "  delete-rule <id> --profile <profile>"
    echo "  doctor [--json]           Check dependencies"
    echo "  export --profile <profile>  Output all enabled rules as JSON"
    echo "  import-proxyman <file> --profile <profile>  Import Proxyman rules"
    echo "  export-proxyman --profile <profile> --output <file>  Export to Proxyman format"
    echo "  help                      Show this help message"
    echo "  version                   Show version info"
    echo "  which                     Show the resolved CLI path"
    echo "  logs                      Tail mitmproxy.log"
    echo "  ls, show                  Aliases for list"
    echo "  on                        Alias for start"
    echo "  off                       Alias for stop"
    echo "  version                   Show version info"
    echo "  ls                        Alias for list"
    echo "  on                        Alias for start"
    echo "  off                       Alias for stop"
    echo "  show                      Alias for list"
    echo ""
    echo "Options:"
    echo "  --profile <name>          Use a specific profile"
    echo "  --verbose                 Show detailed rule output"
    echo "  --preserve-https          Maintain HTTPS for redirected requests"
    echo ""
}

add_rule() {
    local rule_id="$1"
    shift
    local profile="" regex="" host="" port="" scheme="http"
    while [[ $# -gt 0 ]]; do
        case "$1" in
        --profile)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --profile"
                exit 1
            fi
            profile="$2"
            shift 2
            ;;
        --regex)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --regex"
                exit 1
            fi
            regex="$2"
            shift 2
            ;;
        --host)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --host"
                exit 1
            fi
            host="$2"
            shift 2
            ;;
        --port)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --port"
                exit 1
            fi
            port="$2"
            shift 2
            ;;
        --scheme)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --scheme"
                exit 1
            fi
            scheme="$2"
            shift 2
            ;;
        *) shift ;;
        esac
    done
    if [[ -z "$profile" || -z "$rule_id" || -z "$regex" || -z "$host" || -z "$port" ]]; then
        echo "Usage: $SCRIPT_NAME add-rule <rule_id> --profile <profile> --regex <pattern> --host <host> --port <port> [--scheme <http|https>]"
        exit 1
    fi
    jq --arg id "$rule_id" --arg regex "$regex" --arg host "$host" --argjson port "$port" --arg scheme "$scheme" '
    .[$ARGS.named.profile] += [{
      id: $id,
      enabled: true,
      regex: $regex,
      host: $host,
      port: $port,
      scheme: $scheme
    }]' --arg profile "$profile" "$RULES_FILE" >tmp.$$.json && mv tmp.$$.json "$RULES_FILE"
    echo "‚úÖ Rule '$rule_id' added to profile '$profile'"
}
list_rules() {
    local profile
    profile=$(get_profile "$@")

    if ! jq -e ".\"$profile\"" "$RULES_FILE" >/dev/null; then
        echo "‚ùå Profile '$profile' does not exist in $RULES_FILE"
        exit 1
    fi

    jq -c ".\"$profile\"[]" "$RULES_FILE" | while read -r rule; do
        id=$(echo "$rule" | jq -r .id)
        enabled=$(echo "$rule" | jq -r .enabled)
        host=$(echo "$rule" | jq -r .host)
        port=$(echo "$rule" | jq -r .port)
        if is_verbose "$@"; then
            if [[ "$enabled" == "true" ]]; then
                echo "‚úÖ $id ‚Üí http://$host:$port"
            else
                echo "‚ùå $id ‚Üí http://$host:$port (disabled)"
            fi
        else
            status="disabled"
            [[ "$enabled" == "true" ]] && status="enabled"
            echo "$id [$status]"
        fi
    done
}
delete_rule() {
    local rule_id="$1"
    shift
    local profile=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
        --profile)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --profile"
                exit 1
            fi
            profile="$2"
            shift 2
            ;;
        *) shift ;;
        esac
    done
    if [[ -z "$rule_id" || -z "$profile" ]]; then
        echo "Usage: $SCRIPT_NAME delete-rule <rule_id> --profile <profile>"
        exit 1
    fi
    jq ".["$profile"] |= map(select(.id != "$rule_id"))" "$RULES_FILE" >tmp.$$.json && mv tmp.$$.json "$RULES_FILE"
    echo "üóëÔ∏è  Deleted rule '$rule_id' from profile '$profile'"
}

toggle_rule() {
    local rule_id="$1"
    shift
    local profile
    profile=$(get_profile "$@")

    if [[ -z "$rule_id" || -z "$profile" ]]; then
        echo "Usage: $SCRIPT_NAME toggle <rule_id> --profile <profile>"
        exit 1
    fi

    if ! jq -e ".\"$profile\" | type == \"array\"" "$RULES_FILE" >/dev/null; then
        echo "‚ùå Profile '$profile' does not contain a valid rule array."
        exit 1
    fi

    jq --arg rule_id "$rule_id" '
      .[$ARGS.named.profile] |= map(
        if .id == $rule_id then
          .enabled = (if .enabled == true then false else true end)
        else . end
      )
    ' --arg profile "$profile" "$RULES_FILE" >tmp.$$.json && mv tmp.$$.json "$RULES_FILE"

    echo "üîÅ Toggled rule '$rule_id' in profile '$profile'"
}

start_proxy() {
    local profile
    profile=$(get_profile "$@")
    local preserve_https=false
    
    # Check for --preserve-https flag
    for arg in "$@"; do
        [[ "$arg" == "--preserve-https" ]] && preserve_https=true
    done
    
    local script="$SCRIPT_DIR/generated_proxy_map.py"

    echo "import re" >"$script"
    echo "from mitmproxy import http" >>"$script"
    echo "import ssl" >>"$script"
    echo "import os" >>"$script"
    echo "" >>"$script"
    echo "preserve_https = $preserve_https" >>"$script"
    echo "rules = [" >>"$script"

    jq -c ".\"$profile\"[] | select(.enabled == true)" "$RULES_FILE" | while read -r rule; do
        regex=$(echo "$rule" | jq -r .regex)
        host=$(echo "$rule" | jq -r .host)
        port=$(echo "$rule" | jq -r .port)
        scheme=$(echo "$rule" | jq -r '.scheme // "http"')
        echo "  (re.compile(r\"$regex\"), \"$host\", $port, \"$scheme\")," >>"$script"
    done

    echo "]" >>"$script"
    cat <<'EOF' >>"$script"
def request(flow: http.HTTPFlow) -> None:
    url = flow.request.pretty_url
    original_scheme = flow.request.scheme
    
    for pattern, host, port, rule_scheme in rules:
        if pattern.match(url):
            # Determine the target scheme
            if preserve_https and original_scheme == "https":
                target_scheme = "https"
                # For HTTPS preservation, use standard HTTPS port if targeting local development
                if port in [3000, 3001, 8080, 8000, 5000, 5173, 4200]:
                    # These are common dev server ports, keep them as-is
                    target_port = port
                else:
                    target_port = port
            else:
                target_scheme = rule_scheme
                target_port = port
            
            print(f"Matched: {url} ‚Üí {target_scheme}://{host}:{target_port}")
            flow.request.host = host
            flow.request.port = target_port
            flow.request.scheme = target_scheme
            break
EOF

    # Add mitmdump options for better HTTPS handling
    local mitmdump_opts=""
    if [[ "$preserve_https" == "true" ]]; then
        mitmdump_opts="--ssl-insecure"
    fi

    echo "{ \"profile\": \"$profile\", \"preserve_https\": $preserve_https, \"started_at\": \"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\" }" >"$SCRIPT_DIR/last_run.json"
    mitmdump $mitmdump_opts -s "$script" >"$SCRIPT_DIR/mitmproxy.log" 2>&1 &
    local pid=$!
    echo "‚úÖ mitmdump started in background (PID $pid)"
    echo "üìù Logs: tail -f $SCRIPT_DIR/mitmproxy.log"
    
    if [[ "$preserve_https" == "true" ]]; then
        echo "üîí HTTPS preservation enabled - local services should support HTTPS"
    fi
}

status() {
    if pgrep -f mitmdump >/dev/null; then
        echo "‚úÖ mitmdump is running"
    else
        echo "‚ùå mitmdump is not running"
    fi
}

stop_proxy() {
    pkill -f mitmdump && echo "üõë mitmdump stopped" || echo "‚ö†Ô∏è  mitmdump was not running"
}

logs() {
    local log_file="$SCRIPT_DIR/mitmproxy.log"
    if [[ -f "$log_file" ]]; then
        echo "üìÑ Tailing logs from $log_file (press Ctrl+C to stop)"
        tail -f "$log_file"
    else
        echo "‚ùå Log file not found: $log_file"
    fi
}

which_command() {
    echo "üìç Resolved path: $SCRIPT_DIR/$SCRIPT_NAME"
}

doctor() {
    local json_output=false
    local verbose_output=false

    for arg in "$@"; do
        case "$arg" in
        --json) json_output=true ;;
        --verbose) verbose_output=true ;;
        esac
    done

    local mitmproxy_ok=false
    local cert_ok=false
    local mitm_path
    mitm_path=$(command -v mitmdump || true)

    if [[ -x "$mitm_path" ]]; then
        mitmproxy_ok=true
    fi

    local cert_path="$HOME/.mitmproxy/mitmproxy-ca-cert.pem"
    if [[ -f "$cert_path" ]]; then
        cert_ok=true
    fi

    if [[ "$json_output" == true ]]; then
        echo "{"
        echo "  \"mitmproxy_installed\": $mitmproxy_ok,"
        echo "  \"cert_installed\": $cert_ok"
        echo "}"
    elif [[ "$verbose_output" == true ]]; then
        echo "ü©∫ Giant Proxy Diagnostic Report"
        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        echo "üì¶ mitmdump path: ${mitm_path:-Not Found}"
        echo "üìÑ cert path: $cert_path"
        echo ""
        $mitmproxy_ok && echo "‚úÖ mitmdump is installed" || echo "‚ùå mitmdump is NOT installed"
        $cert_ok && echo "‚úÖ mitmproxy certificate is installed" || echo "‚ùå mitmproxy certificate is NOT installed"
        echo ""
    else
        $mitmproxy_ok && echo "‚úÖ mitmdump installed" || echo "‚ùå mitmdump NOT found"
        $cert_ok && echo "‚úÖ mitmproxy cert installed" || echo "‚ùå mitmproxy cert NOT found"
    fi
}

install_cli() {
    local BIN_DIR="$HOME/.local/bin"
    local TARGET="$BIN_DIR/$SCRIPT_NAME"

    echo "üîß Installing $SCRIPT_NAME..."
    mkdir -p "$BIN_DIR"

    ln -sf "$SCRIPT_DIR/$SCRIPT_NAME" "$TARGET"
    chmod +x "$SCRIPT_DIR/$SCRIPT_NAME"

    echo "‚úÖ Symlinked $SCRIPT_NAME to $TARGET"

    if [[ ":$PATH:" != *":$BIN_DIR:"* ]]; then
        echo "‚ö†Ô∏è  $BIN_DIR is not in your PATH"
        echo "   Add this to your shell profile (e.g. ~/.bashrc or ~/.zshrc):"
        echo "   export PATH=\"$BIN_DIR:\$PATH\""
    else
        echo "   You can now run '$SCRIPT_NAME' from anywhere."
    fi
}

create_profile() {
    local profile="$1"
    if [[ -z "$profile" ]]; then
        echo "Usage: $SCRIPT_NAME create-profile <name>"
        exit 1
    fi
    
    if jq -e ".\"$profile\"" "$RULES_FILE" >/dev/null 2>&1; then
        echo "‚ùå Profile '$profile' already exists"
        exit 1
    fi
    
    jq --arg profile "$profile" '. + {($profile): []}' "$RULES_FILE" >tmp.$$.json && mv tmp.$$.json "$RULES_FILE"
    echo "‚úÖ Created profile '$profile'"
}

describe_rule() {
    local rule_id="$1"
    shift
    local profile
    profile=$(get_profile "$@")
    
    if [[ -z "$rule_id" ]]; then
        echo "Usage: $SCRIPT_NAME describe <rule_id> --profile <profile>"
        exit 1
    fi
    
    local rule=$(jq --arg id "$rule_id" ".\"$profile\"[] | select(.id == \$id)" "$RULES_FILE")
    if [[ -z "$rule" ]]; then
        echo "‚ùå Rule '$rule_id' not found in profile '$profile'"
        exit 1
    fi
    
    echo "$rule" | jq .
}

export_rules() {
    local profile
    profile=$(get_profile "$@")
    
    jq ".\"$profile\"" "$RULES_FILE"
}

update_cli() {
    echo "üîÑ Checking for updates..."
    cd "$SCRIPT_DIR" || exit 1
    
    if git rev-parse --git-dir >/dev/null 2>&1; then
        git pull origin main
        echo "‚úÖ Updated to latest version"
    else
        echo "‚ùå Not a git repository. Please update manually."
        exit 1
    fi
}

import_proxyman() {
    local file="$1"
    shift
    local profile=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
        --profile)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --profile"
                exit 1
            fi
            profile="$2"
            shift 2
            ;;
        *) shift ;;
        esac
    done
    
    if [[ -z "$file" || -z "$profile" ]]; then
        echo "Usage: $SCRIPT_NAME import-proxyman <file> --profile <profile>"
        exit 1
    fi
    
    if [[ ! -f "$file" ]]; then
        echo "‚ùå File not found: $file"
        exit 1
    fi
    
    # Create profile if it doesn't exist
    if ! jq -e ".\"$profile\"" "$RULES_FILE" >/dev/null 2>&1; then
        jq --arg profile "$profile" '. + {($profile): []}' "$RULES_FILE" >tmp.$$.json && mv tmp.$$.json "$RULES_FILE"
        echo "üìÅ Created new profile: $profile"
    fi
    
    # Parse Proxyman format (assuming JSON with rules array)
    # Proxyman typically exports rules with: name, matching (with url pattern), action (with host/port)
    local imported_count=0
    
    # Try to parse as Proxyman JSON format
    if jq -e '.rules' "$file" >/dev/null 2>&1; then
        # Proxyman format detected
        jq -c '.rules[]' "$file" 2>/dev/null | while read -r rule; do
            local name=$(echo "$rule" | jq -r '.name // ""')
            local url_pattern=$(echo "$rule" | jq -r '.matching.url // ""')
            local dest_host=$(echo "$rule" | jq -r '.action.host // "localhost"')
            local dest_port=$(echo "$rule" | jq -r '.action.port // 8080')
            local enabled=$(echo "$rule" | jq -r '.enabled // true')
            
            if [[ -n "$name" && -n "$url_pattern" ]]; then
                # Convert Proxyman wildcard patterns to regex
                local regex_pattern=$(echo "$url_pattern" | sed 's/\*/\.\*/g' | sed 's/\?/\\?/g')
                
                # Generate a safe rule ID from the name
                local rule_id=$(echo "$name" | tr ' ' '_' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_]//g')
                
                # Add the rule
                jq --arg id "$rule_id" --arg regex "$regex_pattern" --arg host "$dest_host" \
                   --argjson port "$dest_port" --arg profile "$profile" --argjson enabled "$enabled" '
                .[$profile] += [{
                    id: $id,
                    enabled: $enabled,
                    regex: $regex,
                    host: $host,
                    port: $port,
                    scheme: "http"
                }]' "$RULES_FILE" >tmp.$$.json && mv tmp.$$.json "$RULES_FILE"
                
                ((imported_count++))
                echo "  ‚úì Imported: $name ‚Üí $dest_host:$dest_port"
            fi
        done
    else
        echo "‚ùå Unsupported file format. Expected Proxyman JSON export."
        exit 1
    fi
    
    echo "‚úÖ Imported $imported_count rules to profile '$profile'"
}

export_proxyman() {
    local profile
    profile=$(get_profile "$@")
    local output=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
        --output)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --output"
                exit 1
            fi
            output="$2"
            shift 2
            ;;
        --profile)
            shift 2
            ;;
        *) shift ;;
        esac
    done
    
    if [[ -z "$output" ]]; then
        echo "Usage: $SCRIPT_NAME export-proxyman --profile <profile> --output <file>"
        exit 1
    fi
    
    # Export in Proxyman-compatible format
    echo "{" >"$output"
    echo '  "version": "1.0",' >>"$output"
    echo '  "rules": [' >>"$output"
    
    local first=true
    jq -c ".\"$profile\"[]" "$RULES_FILE" 2>/dev/null | while read -r rule; do
        if [[ "$first" != "true" ]]; then
            echo "," >>"$output"
        fi
        first=false
        
        local id=$(echo "$rule" | jq -r .id)
        local enabled=$(echo "$rule" | jq -r .enabled)
        local regex=$(echo "$rule" | jq -r .regex)
        local host=$(echo "$rule" | jq -r .host)
        local port=$(echo "$rule" | jq -r .port)
        
        # Convert regex back to Proxyman wildcard format (simplified)
        local url_pattern=$(echo "$regex" | sed 's/\.\*/\*/g' | sed 's/\\?/?/g')
        
        cat >>"$output" <<EOF
    {
      "name": "$id",
      "enabled": $enabled,
      "matching": {
        "url": "$url_pattern",
        "method": "*"
      },
      "action": {
        "type": "redirect",
        "host": "$host",
        "port": $port
      }
    }
EOF
    done
    
    echo "" >>"$output"
    echo "  ]" >>"$output"
    echo "}" >>"$output"
    
    echo "‚úÖ Exported profile '$profile' to $output"
}

case "$command" in
list | ls | show) list_rules "$@" ;;
toggle) toggle_rule "$@" ;;
start | on) start_proxy "$@" ;;
stop | off) stop_proxy ;;
status) status ;;
install) install_cli ;;
update) update_cli ;;
create-profile) create_profile "$@" ;;
add-rule) add_rule "$@" ;;
delete-rule) delete_rule "$@" ;;
doctor) doctor "$@" ;;
describe) describe_rule "$@" ;;
export) export_rules "$@" ;;
import-proxyman) import_proxyman "$@" ;;
export-proxyman) export_proxyman "$@" ;;
version | --version | -v) echo "$SCRIPT_NAME version $VERSION" ;;
help | --help | -h) print_help ;;
*) print_help ;;
esac

# === Autocomplete Support ===
_giant_proxy_complete() {
    local cur prev opts profiles rules profile_keys rule_ids
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD - 1]}"
    opts="list toggle start stop status install update create-profile add-rule delete-rule doctor help --profile --verbose --json"

    if [[ "$prev" == "--profile" ]]; then
        profiles=$(jq -r 'keys[]' "$SCRIPT_DIR/rules.json")
        COMPREPLY=($(compgen -W "$profiles" -- "$cur"))
        return 0
    fi

    if [[ "${COMP_WORDS[1]}" =~ ^(toggle|delete-rule)$ ]]; then
        for p in $(jq -r 'keys[]' "$SCRIPT_DIR/rules.json"); do
            rule_ids+=$(jq -r ".[$p][] | .id" "$SCRIPT_DIR/rules.json")
        done
        COMPREPLY=($(compgen -W "$rule_ids" -- "$cur"))
        return 0
    fi

    COMPREPLY=($(compgen -W "$opts" -- "$cur"))
}
complete -F _giant_proxy_complete giant-proxy
