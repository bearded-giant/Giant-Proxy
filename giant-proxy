#!/usr/bin/env bash

# === Constants ===
SCRIPT_NAME="giant-proxy"
VERSION="1.1.0"
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ "$SOURCE" != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"

RULES_FILE="$SCRIPT_DIR/rules.json"
CONFIG_DIR="$HOME/.giant-proxy"
CONFIG_FILE="$CONFIG_DIR/config.json"

command="$1"
shift || true

# === Helpers ===
get_profile() {
    local p=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
        --profile)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing profile name after --profile"
                exit 1
            fi
            p="$2"
            shift 2
            ;;
        *) shift ;;
        esac
    done
    if [[ -z "$p" ]]; then
        echo "‚ùå Missing --profile <name>"
        exit 1
    fi
    echo "$p"
}
is_verbose() {
    for arg in "$@"; do
        [[ "$arg" == "--verbose" ]] && return 0
    done
    return 1
}

# === Config Helpers ===
_ensure_config_dir() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        mkdir -p "$CONFIG_DIR/tmp"
    fi
}

_load_config() {
    _ensure_config_dir
    if [[ -f "$CONFIG_FILE" ]]; then
        cat "$CONFIG_FILE"
    else
        echo '{"backend":"mitmproxy","proxyman_cli":"/Applications/Proxyman.app/Contents/MacOS/proxyman-cli"}'
    fi
}

_save_config() {
    local config="$1"
    _ensure_config_dir
    echo "$config" > "$CONFIG_FILE"
}

_get_backend() {
    _load_config | jq -r '.backend // "mitmproxy"'
}

_generate_proxyman_config() {
    local profile="$1"
    local rule_id="$2"  # optional - if empty, use all enabled rules
    local output_file="$CONFIG_DIR/tmp/active-proxyman.config"

    _ensure_config_dir

    # Generate Proxyman JSON array from rules
    if [[ -n "$rule_id" ]]; then
        # Single rule mode
        jq --arg profile "$profile" --arg rule_id "$rule_id" '
            .[$profile] // [] |
            map(select(.id == $rule_id and .enabled == true)) |
            map({
                id: ("GP-" + .id + "-" + (now | floor | tostring)),
                name: .id,
                isEnabled: true,
                mapFromURL: .regex,
                regex: "useRegex",
                method: {any: {}},
                toURLComponent: {
                    scheme: (.scheme // "http"),
                    host: .host,
                    port: ((.port // 8080) | tostring),
                    path: (.path // ""),
                    query: (.query // "")
                },
                preserveOriginalURL: (.preserveOriginalURL // true),
                preserveHostHeader: (.preserveHostHeader // true),
                fromURLComponent: {query:"",port:"",path:"",host:"",scheme:""},
                isIncludingPaths: false,
                graphQLQueryName: null
            })
        ' "$RULES_FILE" > "$output_file"
    else
        # All enabled rules mode
        jq --arg profile "$profile" '
            .[$profile] // [] |
            map(select(.enabled == true)) |
            to_entries | map(.value + {_idx: .key}) |
            map({
                id: ("GP-" + .id + "-" + (now | floor | tostring) + "-" + (._idx | tostring)),
                name: .id,
                isEnabled: true,
                mapFromURL: .regex,
                regex: "useRegex",
                method: {any: {}},
                toURLComponent: {
                    scheme: (.scheme // "http"),
                    host: .host,
                    port: ((.port // 8080) | tostring),
                    path: (.path // ""),
                    query: (.query // "")
                },
                preserveOriginalURL: (.preserveOriginalURL // true),
                preserveHostHeader: (.preserveHostHeader // true),
                fromURLComponent: {query:"",port:"",path:"",host:"",scheme:""},
                isIncludingPaths: false,
                graphQLQueryName: null
            })
        ' "$RULES_FILE" > "$output_file"
    fi

    echo "$output_file"
}

_start_proxyman() {
    local profile=""
    local rule_id=""
    local preserve_https=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
        --profile)
            profile="$2"
            shift 2
            ;;
        --rule)
            rule_id="$2"
            shift 2
            ;;
        --preserve-https)
            preserve_https=true
            shift
            ;;
        *) shift ;;
        esac
    done

    if [[ -z "$profile" ]]; then
        echo "‚ùå Missing --profile <name>"
        exit 1
    fi

    local config=$(_load_config)
    local cli=$(echo "$config" | jq -r '.proxyman_cli')

    if [[ ! -x "$cli" ]]; then
        echo "‚ùå proxyman-cli not found at: $cli"
        echo "   Set path with: giant-proxy config proxyman_cli /path/to/proxyman-cli"
        exit 1
    fi

    local config_file=$(_generate_proxyman_config "$profile" "$rule_id")
    local rule_count=$(jq 'length' "$config_file")

    if [[ "$rule_count" -eq 0 ]]; then
        echo "‚ùå No enabled rules found"
        if [[ -n "$rule_id" ]]; then
            echo "   Rule '$rule_id' not found or not enabled in profile '$profile'"
        fi
        exit 1
    fi

    # Import config into Proxyman
    "$cli" import "$config_file" 2>/dev/null

    # Save state
    local active_rules=$(jq -r '[.[].name] | join(",")' "$config_file")
    echo "{ \"backend\": \"proxyman\", \"profile\": \"$profile\", \"active_rules\": \"$active_rules\", \"started_at\": \"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\", \"config_file\": \"$config_file\" }" >"$SCRIPT_DIR/last_run.json"

    echo "‚úÖ Proxyman rules imported ($rule_count rules)"
    if [[ -n "$rule_id" ]]; then
        echo "   Rule: $rule_id"
    else
        echo "   Profile: $profile"
    fi
    echo "   Config: $config_file"
}

_stop_proxyman() {
    local config=$(_load_config)
    local cli=$(echo "$config" | jq -r '.proxyman_cli')

    if [[ ! -x "$cli" ]]; then
        echo "‚ö†Ô∏è  proxyman-cli not found, skipping"
    else
        # Import empty config to clear rules
        echo "[]" > "$CONFIG_DIR/tmp/active-proxyman.config"
        "$cli" import "$CONFIG_DIR/tmp/active-proxyman.config" 2>/dev/null
    fi

    echo "{ \"backend\": \"proxyman\", \"stopped_at\": \"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\" }" >"$SCRIPT_DIR/last_run.json"
    echo "üõë Proxyman rules cleared"
}

print_help() {
    echo ""
    echo "üìñ Usage: $SCRIPT_NAME <command> [options]"
    echo ""
    echo "Commands:"
    echo "  list                      List all rules for a profile"
    echo "  toggle <rule_id>          Toggle a rule on/off"
    echo "  describe <rule_id> --profile <profile>  Show full rule JSON"
    echo "  start --profile <p> [--rule <id>]  Start proxy with profile (or single rule)"
    echo "  stop                      Stop proxy"
    echo "  status                    Show current proxy status"
    echo "  config [key] [value]      Show/set configuration (backend, proxyman_cli)"
    echo "  install                   Symlink this CLI to ~/.local/bin"
    echo "  update                    Pull latest version and sync"
    echo "  create-profile <name>     Create a new profile in rules.json"
    echo "  add-rule <id> --profile <profile> --regex <r> --host <h> --port <p> [--scheme <http|https>]"
    echo "  delete-rule <id> --profile <profile>"
    echo "  doctor [--json]           Check dependencies"
    echo "  export --profile <profile>  Output all enabled rules as JSON"
    echo "  import-proxyman <file> --profile <profile>  Import Proxyman rules"
    echo "  export-proxyman --profile <profile> --output <file>  Export to Proxyman format"
    echo "  logs [--filter <text>] [--no-follow] [--json]  View structured logs"
    echo "  which                     Show the resolved CLI path"
    echo "  help, version             Show help or version info"
    echo ""
    echo "Aliases: ls/show=list, on=start, off=stop"
    echo ""
    echo "Options:"
    echo "  --profile <name>          Use a specific profile"
    echo "  --verbose                 Show detailed rule output"
    echo "  --preserve-https          Maintain HTTPS for redirected requests"
    echo ""
}

add_rule() {
    local rule_id="$1"
    shift
    local profile="" regex="" host="" port="" scheme="http"
    while [[ $# -gt 0 ]]; do
        case "$1" in
        --profile)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --profile"
                exit 1
            fi
            profile="$2"
            shift 2
            ;;
        --regex)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --regex"
                exit 1
            fi
            regex="$2"
            shift 2
            ;;
        --host)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --host"
                exit 1
            fi
            host="$2"
            shift 2
            ;;
        --port)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --port"
                exit 1
            fi
            port="$2"
            shift 2
            ;;
        --scheme)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --scheme"
                exit 1
            fi
            scheme="$2"
            shift 2
            ;;
        *) shift ;;
        esac
    done
    if [[ -z "$profile" || -z "$rule_id" || -z "$regex" || -z "$host" || -z "$port" ]]; then
        echo "Usage: $SCRIPT_NAME add-rule <rule_id> --profile <profile> --regex <pattern> --host <host> --port <port> [--scheme <http|https>]"
        exit 1
    fi
    jq --arg id "$rule_id" --arg regex "$regex" --arg host "$host" --argjson port "$port" --arg scheme "$scheme" '
    .[$ARGS.named.profile] += [{
      id: $id,
      enabled: true,
      regex: $regex,
      host: $host,
      port: $port,
      scheme: $scheme
    }]' --arg profile "$profile" "$RULES_FILE" >tmp.$$.json && mv tmp.$$.json "$RULES_FILE"
    echo "‚úÖ Rule '$rule_id' added to profile '$profile'"
}
list_rules() {
    local profile
    profile=$(get_profile "$@")

    if ! jq -e ".\"$profile\"" "$RULES_FILE" >/dev/null; then
        echo "‚ùå Profile '$profile' does not exist in $RULES_FILE"
        exit 1
    fi

    jq -c ".\"$profile\"[]" "$RULES_FILE" | while read -r rule; do
        id=$(echo "$rule" | jq -r .id)
        enabled=$(echo "$rule" | jq -r .enabled)
        host=$(echo "$rule" | jq -r .host)
        port=$(echo "$rule" | jq -r .port)
        if is_verbose "$@"; then
            if [[ "$enabled" == "true" ]]; then
                echo "‚úÖ $id ‚Üí http://$host:$port"
            else
                echo "‚ùå $id ‚Üí http://$host:$port (disabled)"
            fi
        else
            status="disabled"
            [[ "$enabled" == "true" ]] && status="enabled"
            echo "$id [$status]"
        fi
    done
}
delete_rule() {
    local rule_id="$1"
    shift
    local profile=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
        --profile)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --profile"
                exit 1
            fi
            profile="$2"
            shift 2
            ;;
        *) shift ;;
        esac
    done
    if [[ -z "$rule_id" || -z "$profile" ]]; then
        echo "Usage: $SCRIPT_NAME delete-rule <rule_id> --profile <profile>"
        exit 1
    fi
    jq ".["$profile"] |= map(select(.id != "$rule_id"))" "$RULES_FILE" >tmp.$$.json && mv tmp.$$.json "$RULES_FILE"
    echo "üóëÔ∏è  Deleted rule '$rule_id' from profile '$profile'"
}

toggle_rule() {
    local rule_id="$1"
    shift
    local profile
    profile=$(get_profile "$@")

    if [[ -z "$rule_id" || -z "$profile" ]]; then
        echo "Usage: $SCRIPT_NAME toggle <rule_id> --profile <profile>"
        exit 1
    fi

    if ! jq -e ".\"$profile\" | type == \"array\"" "$RULES_FILE" >/dev/null; then
        echo "‚ùå Profile '$profile' does not contain a valid rule array."
        exit 1
    fi

    jq --arg rule_id "$rule_id" '
      .[$ARGS.named.profile] |= map(
        if .id == $rule_id then
          .enabled = (if .enabled == true then false else true end)
        else . end
      )
    ' --arg profile "$profile" "$RULES_FILE" >tmp.$$.json && mv tmp.$$.json "$RULES_FILE"

    echo "üîÅ Toggled rule '$rule_id' in profile '$profile'"
}

start_proxy() {
    local backend=$(_get_backend)

    if [[ "$backend" == "proxyman" ]]; then
        _start_proxyman "$@"
        return
    fi

    # mitmproxy backend (default)
    local profile
    profile=$(get_profile "$@")
    local preserve_https=false

    # Check for --preserve-https flag
    for arg in "$@"; do
        [[ "$arg" == "--preserve-https" ]] && preserve_https=true
    done

    local script="$SCRIPT_DIR/generated_proxy_map.py"

    echo "import re" >"$script"
    echo "from mitmproxy import http" >>"$script"
    echo "import ssl" >>"$script"
    echo "import os" >>"$script"
    echo "" >>"$script"
    # Convert bash boolean to Python boolean
    local py_preserve_https="False"
    if [[ "$preserve_https" == "true" ]]; then
        py_preserve_https="True"
    fi
    echo "preserve_https = $py_preserve_https" >>"$script"
    echo "rules = [" >>"$script"

    jq -c ".\"$profile\"[] | select(.enabled == true)" "$RULES_FILE" | while read -r rule; do
        regex=$(echo "$rule" | jq -r .regex)
        host=$(echo "$rule" | jq -r .host)
        port=$(echo "$rule" | jq -r .port)
        scheme=$(echo "$rule" | jq -r '.scheme // "http"')
        echo "  (re.compile(r\"$regex\"), \"$host\", $port, \"$scheme\")," >>"$script"
    done

    echo "]" >>"$script"
    cat <<'EOF' >>"$script"
import json
import time
import uuid
from datetime import datetime

# Create logs directory if it doesn't exist
import os
log_dir = os.path.join(os.path.dirname(__file__), 'logs')
os.makedirs(log_dir, exist_ok=True)

# Log file path with timestamp
log_file = os.path.join(log_dir, f'proxy_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json')

def log_request(request_id, flow, action, target_host=None, target_port=None, target_scheme=None):
    log_entry = {
        "id": request_id,
        "timestamp": datetime.utcnow().isoformat() + "Z",
        "type": "request",
        "method": flow.request.method,
        "url": flow.request.pretty_url,
        "host": flow.request.host,
        "port": flow.request.port,
        "scheme": flow.request.scheme,
        "path": flow.request.path,
        "headers": dict(flow.request.headers),
        "action": action
    }
    
    if action == "redirect":
        log_entry["redirect"] = {
            "host": target_host,
            "port": target_port,
            "scheme": target_scheme
        }
    
    with open(log_file, 'a') as f:
        f.write(json.dumps(log_entry) + '\n')
    
    # Also print to stdout for real-time monitoring
    if action == "redirect":
        print(f"[{request_id}] Matched: {flow.request.pretty_url} ‚Üí {target_scheme}://{target_host}:{target_port}")
    else:
        print(f"[{request_id}] Passed through: {flow.request.pretty_url}")

def response(flow: http.HTTPFlow) -> None:
    request_id = getattr(flow.request, 'giant_proxy_id', 'unknown')
    
    log_entry = {
        "id": request_id,
        "timestamp": datetime.utcnow().isoformat() + "Z",
        "type": "response",
        "status_code": flow.response.status_code,
        "reason": flow.response.reason,
        "headers": dict(flow.response.headers),
        "duration_ms": int((time.time() - getattr(flow.request, 'giant_proxy_start', time.time())) * 1000)
    }
    
    with open(log_file, 'a') as f:
        f.write(json.dumps(log_entry) + '\n')
    
    print(f"[{request_id}] Response: {flow.response.status_code} ({log_entry['duration_ms']}ms)")

def request(flow: http.HTTPFlow) -> None:
    # Generate unique request ID
    request_id = str(uuid.uuid4())[:8]
    flow.request.giant_proxy_id = request_id
    flow.request.giant_proxy_start = time.time()
    
    url = flow.request.pretty_url
    original_scheme = flow.request.scheme
    matched = False
    
    for pattern, host, port, rule_scheme in rules:
        if pattern.match(url):
            matched = True
            # Determine the target scheme
            if preserve_https and original_scheme == "https":
                target_scheme = "https"
                # For HTTPS preservation, use standard HTTPS port if targeting local development
                if port in [3000, 3001, 8080, 8000, 5000, 5173, 4200]:
                    # These are common dev server ports, keep them as-is
                    target_port = port
                else:
                    target_port = port
            else:
                target_scheme = rule_scheme
                target_port = port
            
            log_request(request_id, flow, "redirect", host, target_port, target_scheme)

            flow.request.host = host
            flow.request.port = target_port
            flow.request.scheme = target_scheme
            break
    
    if not matched:
        log_request(request_id, flow, "passthrough")
EOF

    # Add mitmdump options for better HTTPS handling
    local mitmdump_opts=""
    if [[ "$preserve_https" == "true" ]]; then
        mitmdump_opts="--ssl-insecure"
    fi

    echo "{ \"profile\": \"$profile\", \"preserve_https\": $preserve_https, \"started_at\": \"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\" }" >"$SCRIPT_DIR/last_run.json"
    mitmdump $mitmdump_opts -s "$script" >"$SCRIPT_DIR/mitmproxy.log" 2>&1 &
    local pid=$!
    echo "‚úÖ mitmdump started in background (PID $pid)"
    echo "üìù Logs: tail -f $SCRIPT_DIR/mitmproxy.log"
    
    if [[ "$preserve_https" == "true" ]]; then
        echo "üîí HTTPS preservation enabled - local services should support HTTPS"
    fi
}

status() {
    local backend=$(_get_backend)
    echo "Backend: $backend"
    echo ""

    if [[ -f "$SCRIPT_DIR/last_run.json" ]]; then
        local last_profile=$(jq -r '.profile // "unknown"' "$SCRIPT_DIR/last_run.json")
        local last_started=$(jq -r '.started_at // "unknown"' "$SCRIPT_DIR/last_run.json")
        local last_backend=$(jq -r '.backend // "mitmproxy"' "$SCRIPT_DIR/last_run.json")

        if [[ "$last_backend" == "proxyman" ]]; then
            local active_rules=$(jq -r '.active_rules // "none"' "$SCRIPT_DIR/last_run.json")
            echo "Last run: $last_backend"
            echo "  Profile: $last_profile"
            echo "  Rules: $active_rules"
            echo "  Started: $last_started"
        else
            echo "Last run: mitmproxy"
            echo "  Profile: $last_profile"
            echo "  Started: $last_started"
        fi
        echo ""
    fi

    if [[ "$backend" == "proxyman" ]]; then
        if pgrep -f "Proxyman" >/dev/null; then
            echo "‚úÖ Proxyman app is running"
        else
            echo "‚ö†Ô∏è  Proxyman app is not running"
        fi
    else
        if pgrep -f mitmdump >/dev/null; then
            echo "‚úÖ mitmdump is running"
        else
            echo "‚ùå mitmdump is not running"
        fi
    fi
}

stop_proxy() {
    local backend=$(_get_backend)

    if [[ "$backend" == "proxyman" ]]; then
        _stop_proxyman
        return
    fi

    # mitmproxy backend (default)
    pkill -f mitmdump && echo "üõë mitmdump stopped" || echo "‚ö†Ô∏è  mitmdump was not running"
}

logs() {
    local filter=""
    local follow=true
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
        --filter)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --filter"
                exit 1
            fi
            filter="$2"
            shift 2
            ;;
        --no-follow)
            follow=false
            shift
            ;;
        --json)
            json_output=true
            shift
            ;;
        *) shift ;;
        esac
    done
    
    # First check for new JSON logs
    local logs_dir="$SCRIPT_DIR/logs"
    if [[ -d "$logs_dir" ]]; then
        # Find the most recent log file
        local latest_log=$(ls -t "$logs_dir"/proxy_*.json 2>/dev/null | head -1)
        
        if [[ -n "$latest_log" ]]; then
            echo "üìÑ Reading structured logs from $latest_log"
            
            if [[ "$json_output" == "true" ]]; then
                # Output raw JSON
                if [[ -n "$filter" ]]; then
                    if [[ "$follow" == "true" ]]; then
                        tail -f "$latest_log" | grep "$filter"
                    else
                        grep "$filter" "$latest_log"
                    fi
                else
                    if [[ "$follow" == "true" ]]; then
                        tail -f "$latest_log"
                    else
                        cat "$latest_log"
                    fi
                fi
            else
                # Pretty print logs
                local print_cmd='jq -r '"'"'"\(.timestamp) [\(.id)] \(.type | ascii_upcase) \(.method // "") \(.url // .status_code) \(if .action == "redirect" then "‚Üí \(.redirect.scheme)://\(.redirect.host):\(.redirect.port)" elif .duration_ms then "(\(.duration_ms)ms)" else "" end)"'"'"
                
                if [[ -n "$filter" ]]; then
                    print_cmd="$print_cmd | grep -i '$filter'"
                fi
                
                if [[ "$follow" == "true" ]]; then
                    echo "Press Ctrl+C to stop..."
                    tail -f "$latest_log" | while read line; do
                        echo "$line" | jq -r '"\(.timestamp) [\(.id)] \(.type | ascii_upcase) \(.method // "") \(.url // .status_code) \(if .action == "redirect" then "‚Üí \(.redirect.scheme)://\(.redirect.host):\(.redirect.port)" elif .duration_ms then "(\(.duration_ms)ms)" else "" end)"' 2>/dev/null || echo "$line"
                    done
                else
                    cat "$latest_log" | while read line; do
                        echo "$line" | jq -r '"\(.timestamp) [\(.id)] \(.type | ascii_upcase) \(.method // "") \(.url // .status_code) \(if .action == "redirect" then "‚Üí \(.redirect.scheme)://\(.redirect.host):\(.redirect.port)" elif .duration_ms then "(\(.duration_ms)ms)" else "" end)"' 2>/dev/null || echo "$line"
                    done | { [[ -n "$filter" ]] && grep -i "$filter" || cat; }
                fi
            fi
            return
        fi
    fi
    
    # Fallback to old log format
    local log_file="$SCRIPT_DIR/mitmproxy.log"
    if [[ -f "$log_file" ]]; then
        echo "üìÑ Tailing logs from $log_file (press Ctrl+C to stop)"
        if [[ "$follow" == "true" ]]; then
            tail -f "$log_file"
        else
            cat "$log_file"
        fi
    else
        echo "‚ùå No log files found"
    fi
}

which_command() {
    echo "üìç Resolved path: $SCRIPT_DIR/$SCRIPT_NAME"
}

config_cmd() {
    local key="$1"
    local value="$2"

    if [[ -z "$key" ]]; then
        # Show current config
        echo "‚öôÔ∏è  Giant Proxy Configuration"
        echo "   Config file: $CONFIG_FILE"
        echo ""
        local config=$(_load_config)
        local backend=$(echo "$config" | jq -r '.backend // "mitmproxy"')
        local proxyman_cli=$(echo "$config" | jq -r '.proxyman_cli // "/Applications/Proxyman.app/Contents/MacOS/proxyman-cli"')
        echo "   backend:      $backend"
        echo "   proxyman_cli: $proxyman_cli"
        return
    fi

    if [[ -z "$value" ]]; then
        # Show specific key
        local config=$(_load_config)
        echo "$config" | jq -r ".${key} // empty"
        return
    fi

    # Set value
    local config=$(_load_config)
    local new_config=$(echo "$config" | jq --arg key "$key" --arg value "$value" '.[$key] = $value')
    _save_config "$new_config"
    echo "‚úÖ Set $key = $value"
}

doctor() {
    local json_output=false
    local verbose_output=false

    for arg in "$@"; do
        case "$arg" in
        --json) json_output=true ;;
        --verbose) verbose_output=true ;;
        esac
    done

    local backend=$(_get_backend)
    local mitmproxy_ok=false
    local cert_ok=false
    local proxyman_ok=false
    local proxyman_cli_ok=false

    # Check mitmproxy
    local mitm_path
    mitm_path=$(command -v mitmdump || true)
    if [[ -x "$mitm_path" ]]; then
        mitmproxy_ok=true
    fi

    local cert_path="$HOME/.mitmproxy/mitmproxy-ca-cert.pem"
    if [[ -f "$cert_path" ]]; then
        cert_ok=true
    fi

    # Check Proxyman
    local proxyman_cli=$(_load_config | jq -r '.proxyman_cli')
    if [[ -x "$proxyman_cli" ]]; then
        proxyman_cli_ok=true
    fi
    if [[ -d "/Applications/Proxyman.app" ]]; then
        proxyman_ok=true
    fi

    if [[ "$json_output" == true ]]; then
        echo "{"
        echo "  \"backend\": \"$backend\","
        echo "  \"mitmproxy_installed\": $mitmproxy_ok,"
        echo "  \"cert_installed\": $cert_ok,"
        echo "  \"proxyman_app_installed\": $proxyman_ok,"
        echo "  \"proxyman_cli_available\": $proxyman_cli_ok"
        echo "}"
    elif [[ "$verbose_output" == true ]]; then
        echo "ü©∫ Giant Proxy Diagnostic Report"
        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        echo "üîß Current backend: $backend"
        echo ""
        echo "mitmproxy:"
        echo "  üì¶ mitmdump path: ${mitm_path:-Not Found}"
        echo "  üìÑ cert path: $cert_path"
        $mitmproxy_ok && echo "  ‚úÖ mitmdump is installed" || echo "  ‚ùå mitmdump is NOT installed"
        $cert_ok && echo "  ‚úÖ certificate is installed" || echo "  ‚ùå certificate is NOT installed"
        echo ""
        echo "Proxyman:"
        echo "  üì¶ CLI path: $proxyman_cli"
        $proxyman_ok && echo "  ‚úÖ Proxyman.app is installed" || echo "  ‚ùå Proxyman.app is NOT installed"
        $proxyman_cli_ok && echo "  ‚úÖ proxyman-cli is available" || echo "  ‚ùå proxyman-cli is NOT available"
        echo ""
    else
        echo "Backend: $backend"
        echo ""
        echo "mitmproxy:"
        $mitmproxy_ok && echo "  ‚úÖ mitmdump installed" || echo "  ‚ùå mitmdump NOT found"
        $cert_ok && echo "  ‚úÖ mitmproxy cert installed" || echo "  ‚ùå mitmproxy cert NOT found"
        echo ""
        echo "Proxyman:"
        $proxyman_ok && echo "  ‚úÖ Proxyman.app installed" || echo "  ‚ùå Proxyman.app NOT found"
        $proxyman_cli_ok && echo "  ‚úÖ proxyman-cli available" || echo "  ‚ùå proxyman-cli NOT found"
    fi
}

install_cli() {
    local BIN_DIR="$HOME/.local/bin"
    local TARGET="$BIN_DIR/$SCRIPT_NAME"

    echo "üîß Installing $SCRIPT_NAME..."
    mkdir -p "$BIN_DIR"

    ln -sf "$SCRIPT_DIR/$SCRIPT_NAME" "$TARGET"
    chmod +x "$SCRIPT_DIR/$SCRIPT_NAME"

    echo "‚úÖ Symlinked $SCRIPT_NAME to $TARGET"

    if [[ ":$PATH:" != *":$BIN_DIR:"* ]]; then
        echo "‚ö†Ô∏è  $BIN_DIR is not in your PATH"
        echo "   Add this to your shell profile (e.g. ~/.bashrc or ~/.zshrc):"
        echo "   export PATH=\"$BIN_DIR:\$PATH\""
    else
        echo "   You can now run '$SCRIPT_NAME' from anywhere."
    fi
}

create_profile() {
    local profile="$1"
    if [[ -z "$profile" ]]; then
        echo "Usage: $SCRIPT_NAME create-profile <name>"
        exit 1
    fi
    
    if jq -e ".\"$profile\"" "$RULES_FILE" >/dev/null 2>&1; then
        echo "‚ùå Profile '$profile' already exists"
        exit 1
    fi
    
    jq --arg profile "$profile" '. + {($profile): []}' "$RULES_FILE" >tmp.$$.json && mv tmp.$$.json "$RULES_FILE"
    echo "‚úÖ Created profile '$profile'"
}

describe_rule() {
    local rule_id="$1"
    shift
    local profile
    profile=$(get_profile "$@")
    
    if [[ -z "$rule_id" ]]; then
        echo "Usage: $SCRIPT_NAME describe <rule_id> --profile <profile>"
        exit 1
    fi
    
    local rule=$(jq --arg id "$rule_id" ".\"$profile\"[] | select(.id == \$id)" "$RULES_FILE")
    if [[ -z "$rule" ]]; then
        echo "‚ùå Rule '$rule_id' not found in profile '$profile'"
        exit 1
    fi
    
    echo "$rule" | jq .
}

export_rules() {
    local profile
    profile=$(get_profile "$@")
    
    jq ".\"$profile\"" "$RULES_FILE"
}

update_cli() {
    echo "üîÑ Checking for updates..."
    cd "$SCRIPT_DIR" || exit 1
    
    if git rev-parse --git-dir >/dev/null 2>&1; then
        git pull origin main
        echo "‚úÖ Updated to latest version"
    else
        echo "‚ùå Not a git repository. Please update manually."
        exit 1
    fi
}

import_proxyman() {
    local file="$1"
    shift
    local profile=""
    local auto_detect=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
        --profile)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --profile"
                exit 1
            fi
            profile="$2"
            shift 2
            ;;
        --auto-detect)
            auto_detect=true
            shift
            ;;
        *) shift ;;
        esac
    done
    
    if [[ -z "$file" ]]; then
        echo "Usage: $SCRIPT_NAME import-proxyman <file> [--profile <profile>] [--auto-detect]"
        echo "  --auto-detect: Automatically route rules to profiles based on URL patterns"
        exit 1
    fi
    
    if [[ ! -f "$file" ]]; then
        echo "‚ùå File not found: $file"
        exit 1
    fi
    
    # Helper function to detect environment from URL
    detect_environment() {
        local url="$1"
        # Handle both escaped and unescaped patterns
        # Check for environment subdomains in various patterns
        if [[ "$url" =~ (\\\.|\.)(stage)(\\\.|\.)|admin\\\.stage\\\.rechargeapps ]]; then
            echo "stage"
        elif [[ "$url" =~ (\\\.|\.)(preprod)(\\\.|\.)|\\\.preprod\\\.rechargeapps ]]; then
            echo "preprod"
        elif [[ "$url" =~ (\\\.|\.)(prestage)(\\\.|\.)|\\\.prestage\\\.rechargeapps ]]; then
            echo "prestage"
        elif [[ "$url" =~ \\\.admin\\\.rechargeapps\\\.com|^.*admin\.rechargeapps\.com ]] && [[ ! "$url" =~ (stage|preprod|prestage) ]]; then
            echo "prod"
        else
            echo "unknown"
        fi
    }
    
    # If auto-detect and no profile specified, we'll route each rule individually
    if [[ "$auto_detect" == "true" && -z "$profile" ]]; then
        echo "üîç Auto-detecting environments from URL patterns..."
        local detected_envs=()
        
        # First pass: detect all environments
        if jq -e '.[0]' "$file" >/dev/null 2>&1; then
            while read -r url; do
                local env=$(detect_environment "$url")
                if [[ "$env" != "unknown" ]] && [[ ! " ${detected_envs[@]} " =~ " ${env} " ]]; then
                    detected_envs+=("$env")
                fi
            done < <(jq -r '.[].mapFromURL // ""' "$file" 2>/dev/null)
        fi
        
        # Create profiles if needed
        for env in "${detected_envs[@]}"; do
            if ! jq -e ".\"$env\"" "$RULES_FILE" >/dev/null 2>&1; then
                jq --arg profile "$env" '. + {($profile): []}' "$RULES_FILE" >tmp.$$.json && mv tmp.$$.json "$RULES_FILE"
                echo "üìÅ Created new profile: $env"
            fi
        done
    elif [[ -n "$profile" ]]; then
        # Create profile if it doesn't exist
        if ! jq -e ".\"$profile\"" "$RULES_FILE" >/dev/null 2>&1; then
            jq --arg profile "$profile" '. + {($profile): []}' "$RULES_FILE" >tmp.$$.json && mv tmp.$$.json "$RULES_FILE"
            echo "üìÅ Created new profile: $profile"
        fi
    else
        echo "‚ùå Either specify --profile or use --auto-detect"
        exit 1
    fi
    
    # Parse Proxyman format (assuming JSON with rules array)
    # Proxyman typically exports rules with: name, matching (with url pattern), action (with host/port)
    local imported_count=0
    
    # Try to parse as Proxyman JSON format
    # Check if it's an array (Proxyman Map Remote format)
    if jq -e '.[0]' "$file" >/dev/null 2>&1; then
        # Proxyman Map Remote format detected
        jq -c '.[]' "$file" 2>/dev/null | while read -r rule; do
            local name=$(echo "$rule" | jq -r '.name // ""')
            local regex_pattern=$(echo "$rule" | jq -r '.mapFromURL // ""')
            local dest_scheme=$(echo "$rule" | jq -r '.toURLComponent.scheme // "http"')
            local dest_host=$(echo "$rule" | jq -r '.toURLComponent.host // "localhost"')
            local dest_port=$(echo "$rule" | jq -r '.toURLComponent.port // "8080"')
            local dest_path=$(echo "$rule" | jq -r '.toURLComponent.path // ""')
            local dest_query=$(echo "$rule" | jq -r '.toURLComponent.query // ""')
            local enabled=$(echo "$rule" | jq -r '.isEnabled // true')
            local preserveOriginalURL=$(echo "$rule" | jq -r '.preserveOriginalURL // true')
            local preserveHostHeader=$(echo "$rule" | jq -r '.preserveHostHeader // true')

            if [[ -n "$name" && -n "$regex_pattern" ]]; then
                # Determine target profile BEFORE unescaping (for detection)
                local target_profile="$profile"
                if [[ "$auto_detect" == "true" && -z "$profile" ]]; then
                    # Use the original escaped pattern for detection
                    target_profile=$(detect_environment "$regex_pattern")
                    if [[ "$target_profile" == "unknown" ]]; then
                        echo "  ‚ö†Ô∏è  Skipping rule '$name' - couldn't detect environment from URL"
                        continue
                    fi
                fi
                
                # Now unescape slashes for storage
                regex_pattern=$(echo "$regex_pattern" | sed 's/\\\//\//g')
                
                # Generate a safe rule ID from the name
                local rule_id=$(echo "$name" | tr ' ' '_' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_]//g')
                
                # Add the rule
                jq --arg id "$rule_id" --arg regex "$regex_pattern" --arg host "$dest_host" \
                   --argjson port "$dest_port" --arg profile "$target_profile" --argjson enabled "$enabled" \
                   --arg scheme "$dest_scheme" --arg path "$dest_path" --arg query "$dest_query" \
                   --argjson preserveOriginalURL "$preserveOriginalURL" \
                   --argjson preserveHostHeader "$preserveHostHeader" '
                .[$profile] += [{
                    id: $id,
                    enabled: $enabled,
                    regex: $regex,
                    host: $host,
                    port: $port,
                    scheme: $scheme,
                    path: $path,
                    query: $query,
                    preserveOriginalURL: $preserveOriginalURL,
                    preserveHostHeader: $preserveHostHeader
                }]' "$RULES_FILE" >tmp.$$.json && mv tmp.$$.json "$RULES_FILE"
                
                ((imported_count++))
                echo "  ‚úì Imported to $target_profile: $name ‚Üí $dest_scheme://$dest_host:$dest_port"
            fi
        done
    # Check for other format with .rules array
    elif jq -e '.rules' "$file" >/dev/null 2>&1; then
        # Alternative Proxyman format
        jq -c '.rules[]' "$file" 2>/dev/null | while read -r rule; do
            local name=$(echo "$rule" | jq -r '.name // ""')
            local url_pattern=$(echo "$rule" | jq -r '.matching.url // ""')
            local dest_host=$(echo "$rule" | jq -r '.action.host // "localhost"')
            local dest_port=$(echo "$rule" | jq -r '.action.port // 8080')
            local enabled=$(echo "$rule" | jq -r '.enabled // true')
            
            if [[ -n "$name" && -n "$url_pattern" ]]; then
                # Convert Proxyman wildcard patterns to regex
                local regex_pattern=$(echo "$url_pattern" | sed 's/\*/\.\*/g' | sed 's/\?/\\?/g')
                
                # Generate a safe rule ID from the name
                local rule_id=$(echo "$name" | tr ' ' '_' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_]//g')
                
                # Add the rule
                jq --arg id "$rule_id" --arg regex "$regex_pattern" --arg host "$dest_host" \
                   --argjson port "$dest_port" --arg profile "$profile" --argjson enabled "$enabled" '
                .[$profile] += [{
                    id: $id,
                    enabled: $enabled,
                    regex: $regex,
                    host: $host,
                    port: $port,
                    scheme: "http"
                }]' "$RULES_FILE" >tmp.$$.json && mv tmp.$$.json "$RULES_FILE"
                
                ((imported_count++))
                echo "  ‚úì Imported: $name ‚Üí $dest_host:$dest_port"
            fi
        done
    else
        echo "‚ùå Unsupported file format. Expected Proxyman JSON export."
        exit 1
    fi
    
    echo "‚úÖ Imported $imported_count rules to profile '$profile'"
}

export_proxyman() {
    local profile
    profile=$(get_profile "$@")
    local output=""
    local format="simple"  # simple or map-remote
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
        --output)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --output"
                exit 1
            fi
            output="$2"
            shift 2
            ;;
        --format)
            if [[ -z "$2" || "$2" == --* ]]; then
                echo "‚ùå Missing value for --format"
                exit 1
            fi
            format="$2"
            shift 2
            ;;
        --profile)
            shift 2
            ;;
        *) shift ;;
        esac
    done
    
    if [[ -z "$output" ]]; then
        echo "Usage: $SCRIPT_NAME export-proxyman --profile <profile> --output <file> [--format <simple|map-remote>]"
        exit 1
    fi
    
    if [[ "$format" == "map-remote" ]]; then
        # Export in Proxyman Map Remote format (array)
        echo "[" >"$output"
        
        local first=true
        jq -c ".\"$profile\"[]" "$RULES_FILE" 2>/dev/null | while read -r rule; do
            if [[ "$first" != "true" ]]; then
                echo "," >>"$output"
            fi
            first=false
            
            local id=$(echo "$rule" | jq -r .id)
            local enabled=$(echo "$rule" | jq -r .enabled)
            local regex=$(echo "$rule" | jq -r .regex)
            local host=$(echo "$rule" | jq -r .host)
            local port=$(echo "$rule" | jq -r .port)
            local scheme=$(echo "$rule" | jq -r '.scheme // "http"')
            
            # Escape slashes for Proxyman
            local escaped_regex=$(echo "$regex" | sed 's/\//\\\//g')
            
            # Generate a UUID-like ID (simplified)
            local uuid=$(uuidgen 2>/dev/null || echo "$(date +%s)-$(echo $RANDOM)")
            
            cat >>"$output" <<EOF
  {
    "id": "$uuid",
    "isIncludingPaths": true,
    "name": "$id",
    "fromURLComponent": {
      "scheme": "",
      "host": "",
      "port": "",
      "path": "",
      "query": ""
    },
    "method": {
      "any": {}
    },
    "preserveHostHeader": false,
    "graphQLQueryName": null,
    "isEnabled": $enabled,
    "toURLComponent": {
      "scheme": "$scheme",
      "host": "$host",
      "port": "$port",
      "path": "/",
      "query": ""
    },
    "mapFromURL": "$escaped_regex",
    "preserveOriginalURL": false,
    "regex": "useRegex"
  }
EOF
        done
        
        echo "" >>"$output"
        echo "]" >>"$output"
    else
        # Export in simple Proxyman format
        echo "{" >"$output"
        echo '  "version": "1.0",' >>"$output"
        echo '  "rules": [' >>"$output"
        
        local first=true
        jq -c ".\"$profile\"[]" "$RULES_FILE" 2>/dev/null | while read -r rule; do
            if [[ "$first" != "true" ]]; then
                echo "," >>"$output"
            fi
            first=false
            
            local id=$(echo "$rule" | jq -r .id)
            local enabled=$(echo "$rule" | jq -r .enabled)
            local regex=$(echo "$rule" | jq -r .regex)
            local host=$(echo "$rule" | jq -r .host)
            local port=$(echo "$rule" | jq -r .port)
            
            # Convert regex back to Proxyman wildcard format (simplified)
            local url_pattern=$(echo "$regex" | sed 's/\.\*/\*/g' | sed 's/\\?/?/g')
            
            cat >>"$output" <<EOF
    {
      "name": "$id",
      "enabled": $enabled,
      "matching": {
        "url": "$url_pattern",
        "method": "*"
      },
      "action": {
        "type": "redirect",
        "host": "$host",
        "port": $port
      }
    }
EOF
        done
        
        echo "" >>"$output"
        echo "  ]" >>"$output"
        echo "}" >>"$output"
    fi
    
    echo "‚úÖ Exported profile '$profile' to $output (format: $format)"
}

case "$command" in
list | ls | show) list_rules "$@" ;;
toggle) toggle_rule "$@" ;;
start | on) start_proxy "$@" ;;
stop | off) stop_proxy ;;
status) status ;;
logs) logs "$@" ;;
install) install_cli ;;
update) update_cli ;;
create-profile) create_profile "$@" ;;
add-rule) add_rule "$@" ;;
delete-rule) delete_rule "$@" ;;
doctor) doctor "$@" ;;
describe) describe_rule "$@" ;;
export) export_rules "$@" ;;
import-proxyman) import_proxyman "$@" ;;
export-proxyman) export_proxyman "$@" ;;
config) config_cmd "$@" ;;
which) which_command ;;
version | --version | -v) echo "$SCRIPT_NAME version $VERSION" ;;
help | --help | -h) print_help ;;
*) print_help ;;
esac

# === Autocomplete Support ===
_giant_proxy_complete() {
    local cur prev opts profiles rules profile_keys rule_ids
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD - 1]}"
    opts="list toggle start stop status install update create-profile add-rule delete-rule doctor help --profile --verbose --json"

    if [[ "$prev" == "--profile" ]]; then
        profiles=$(jq -r 'keys[]' "$SCRIPT_DIR/rules.json")
        COMPREPLY=($(compgen -W "$profiles" -- "$cur"))
        return 0
    fi

    if [[ "${COMP_WORDS[1]}" =~ ^(toggle|delete-rule)$ ]]; then
        for p in $(jq -r 'keys[]' "$SCRIPT_DIR/rules.json"); do
            rule_ids+=$(jq -r ".[$p][] | .id" "$SCRIPT_DIR/rules.json")
        done
        COMPREPLY=($(compgen -W "$rule_ids" -- "$cur"))
        return 0
    fi

    COMPREPLY=($(compgen -W "$opts" -- "$cur"))
}
complete -F _giant_proxy_complete giant-proxy
